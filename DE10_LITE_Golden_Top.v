// ============================================================================
//   Ver  :| Author					:| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du			:| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

//`define ENABLE_ADC_CLOCK
`define ENABLE_CLOCK1
//`define ENABLE_CLOCK2
//`define ENABLE_SDRAM
`define ENABLE_HEX0
`define ENABLE_HEX1
`define ENABLE_HEX2
`define ENABLE_HEX3
`define ENABLE_HEX4
`define ENABLE_HEX5
`define ENABLE_KEY
`define ENABLE_LED
//`define ENABLE_SW
//`define ENABLE_VGA
//`define ENABLE_ACCELEROMETER
//`define ENABLE_ARDUINO
//`define ENABLE_GPIO

module DE10_LITE_Golden_Top(

	//////////// ADC CLOCK: 3.3-V LVTTL //////////
`ifdef ENABLE_ADC_CLOCK
	input 		          		ADC_CLK_10,
`endif
	//////////// CLOCK 1: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK1
	input 		          		MAX10_CLK1_50,
`endif
/*
	//////////// CLOCK 2: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK2
	input 		          		MAX10_CLK2_50,
`endif

	//////////// SDRAM: 3.3-V LVTTL //////////
`ifdef ENABLE_SDRAM
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,
`endif
*/
	//////////// SEG7: 3.3-V LVTTL //////////
`ifdef ENABLE_HEX0
	output		     [7:0]		HEX0,
`endif
`ifdef ENABLE_HEX1
	output		     [7:0]		HEX1,
`endif
`ifdef ENABLE_HEX2
	output		     [7:0]		HEX2,
`endif
`ifdef ENABLE_HEX3
	output		     [7:0]		HEX3,
`endif
`ifdef ENABLE_HEX4
	output		     [7:0]		HEX4,
`endif
`ifdef ENABLE_HEX5
	output		     [7:0]		HEX5,
`endif

	//////////// KEY: 3.3 V SCHMITT TRIGGER //////////
`ifdef ENABLE_KEY
	input 		     [1:0]		KEY,
`endif

	//////////// LED: 3.3-V LVTTL //////////
`ifdef ENABLE_LED
	output		     [9:0]		LEDR,
`endif
/*
	//////////// SW: 3.3-V LVTTL //////////
`ifdef ENABLE_SW
	input 		     [9:0]		SW,
`endif

	//////////// VGA: 3.3-V LVTTL //////////
`ifdef ENABLE_VGA
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,
`endif

	//////////// Accelerometer: 3.3-V LVTTL //////////
`ifdef ENABLE_ACCELEROMETER
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,
`endif

	//////////// Arduino: 3.3-V LVTTL //////////
`ifdef ENABLE_ARDUINO
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,
`endif

	//////////// GPIO, GPIO connect to GPIO Default: 3.3-V LVTTL //////////
`ifdef ENABLE_GPIO
	inout 		    [35:0]		GPIO
`endif
*/
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

    wire clk50 = MAX10_CLK1_50; // declare and assign in one expression (and shortens name)
    wire [1:0] buttonPress;     // debounce output
    wire       oneMsPulse;      // high for 1 cc every 1 msec

    reg [ 1:0]  buttonPress_dly                    ; // delay each bit of buttonPress by 1 cc for falling edge detection
    reg         stopLED                            ; // 1 bit register to store if the user has stopped or started game
    reg         showHiScore      = 0               ; // 1 bit register to store if user wants to see hi score
	 reg			 rstVars          = 0               ; // 1 bit register for one-time var resets
    reg [ 9:0]  currentLED       = 10'b0000000000  ; // 10 bits 
	 reg [47:0]  hiScoreDisp      = 48'hFFFFFFFFFFC0; // 48 bits for display
	 reg [47:0]  currentScoreDisp = 48'hFFFFFFFFFFFF; // 48 bits for display
	 reg [47:0]  displayText      = 48'hFFFFFFFFFFFF; // 48 bits for display
	 
	 integer msCount      = 0; // counter for timing/logic
	 integer i            = 0; // index at which the current LED that is on will be
	 integer jackpot      = 5; // index that the jackpot will be at (randomize this later for cool points)
	 integer dist			 = 0; // distance of i from jackpot
	 integer currentScore = 0; // current score to be displayed
	 integer hiScore      = 0; // high score to also be displayed
	
	 always @(posedge clk50) begin
		buttonPress_dly <= buttonPress; // delaying button by one cycle
		if (buttonPress[0] == 1'b0 && buttonPress_dly[0]==1'b1) begin
			stopLED <= ~stopLED; // set stopLED on button press
		end
	 end
	
	 always @(posedge oneMsPulse) begin
		if (stopLED) begin
			currentLED[9:0] <= {10'b0000000000};
			// logic for determining distance from jackpot
			if (i <= jackpot) begin dist = jackpot - i; end
			else begin dist = i - jackpot; end
			// logic to calculate currentScore
			case (dist)
				0       : begin currentScore = 100; currentScoreDisp[47:0] <= 48'hFFFFFFF9C0C0; end
				1       : begin currentScore =  25; currentScoreDisp[47:0] <= 48'hFFFFFFFFA492; end
				2       : begin currentScore =  10; currentScoreDisp[47:0] <= 48'hFFFFFFFFF9C0; end
				3       : begin currentScore =   5; currentScoreDisp[47:0] <= 48'hFFFFFFFFFF92; end
				default : begin currentScore =   0; currentScoreDisp[47:0] <= 48'hFFFFFFFFFFC0; end
			endcase
			// logic to figure out if the new score is the high score
			if (currentScore >= hiScore) begin hiScore = currentScore; hiScoreDisp[47:0] = currentScoreDisp[47:0]; end
						
			// driving the display
			if (rstVars) begin msCount <= 0; rstVars <= 1; end
			msCount <= msCount + 1;
			if (msCount <= 500) begin
				displayText[47:0] <= 48'hC1AFFF92A7AF; // display "Ur Scr"
			end
			else if (msCount > 500 && msCount <= 1500) begin
				displayText[47:0] <= currentScoreDisp[47:0]; // display current Score
			end
			else if (msCount > 1500 && msCount <= 2000) begin
				displayText[47:0] <= 48'h89F9FF92A7AF; // display "HI Scr"
			end
			else if (msCount >2000 && msCount <= 3000) begin
				displayText[47:0] <= hiScoreDisp[47:0]; // display high Score
			end
			
			else begin
				msCount <=0; // reset ms count
			end
			
		end else begin
			currentScore = 0;
			rstVars <= 1;
			displayText[47:0] <= 48'hFFFFFFFFFFFF; // set display to blank
			msCount <= msCount + 1;
			if (msCount < 100) begin
					if (msCount == 1) begin
						currentLED[i] <= ~currentLED[i];
					end	
			end else begin
				msCount <= 0;
				currentLED[9:0] <= {10'b0000000000};
				if (i == 9) begin
					i <= 0;
				end else begin
					i <= i + 1;
				end
				currentLED[jackpot] <= ~currentLED[jackpot];
			end
		end
	 end
    assign LEDR = {currentLED} ;
	 assign {HEX5,HEX4,HEX3,HEX2,HEX1,HEX0}  = {displayText[47:0]};

//=======================================================
//  Structural coding
//=======================================================

// outputs a pulse every millisecond -> important for timing logic
msec_timer #(
	.FREQ_KHZ(50000)
)  u_timer (
	.clk	      (clk50),
	.msec_pulse (oneMsPulse)
);

// debouncing pair
debounce #(.DWELL_CNT(16'd1)) dbc0 (
	.clk	   (clk50),
	.sig_in  (KEY[0]),
	.sig_out (buttonPress[0])
);

endmodule


